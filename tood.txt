구조체 트리

Store
    - license
    - version
    - contractName
    - functions[]
        - name
        - params[]
            - name
            - type
        - return[]
            - name
            - type
        - var[]
    - globals[]
        - name
        - type
        - initValue


함수 이름이 같으면 안된다고 말하기 -> 구조체 안의 함수 이름이랑 같은지 체크

모든 기술적 기능을 모아둔 파일 하나 생성

변수는 다 객체로 가져오기 -> 그래야 해당 객체 안에 있는 함수들에 접근 가능

함수랑 변수는 이름이 같으면 안 됨

인터페이스 따로 만들 수 있게 해야함

인터페이스로 가져온 객체는 우클릭 했을 때 리스트에 해당 함수의 function들을 가져와서 보여주기

이미 기존에 있는 컨트랙트와 인터페이스를 사용한다면?

컨트랙트 자체의 인터페이스 지정도 가능해야함 -> 그러면 해당 컨트랙트 안에 인터페이스의 모든 함수가 다 정의되었는지 체크해야함

나중에 다른 파일에서 사용할때는 해당 인터페이스의 대한 정의가 되어있는지 체크해야함(일부만 정의해도 되는데 그러면 정의된 함수 리스트만 가져와야하나?)

의존성 검사기 만들기 or 함수가 인터페이스를 정의할 때 다 정의했는지 아니면 특정 어떤 함수들을 정의했는지 명시하기

bp를 컴파일해서 바이트코드로 만드는 놈 만들기

핀들은 전체를 모아둔 allocateDefaultPins라는 객체에 다 저장되어있고 상속 받아서 필요한 것들을 추가

이벤트 처리 기능

tostring 등등 형변환 기능

변수 타입 변하면 전체 코드에서 해당 변수 사용되는 곳 체크하고 이상 있는지 확인

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

await으로 의존성 타고 내려가서 밑에서부터 쭉 진행?

프론트 처리

1. 노드에 연결할 때 변수 타입 맞는지 -> graph에서 처리
2. 값이 어디서 어디로 가는지
3. 노드(id, type, inputs, outputs) 엣지만 저장해서 백엔드에 보내기. -> 백엔드는 엣지 기반으로 짜기

프론트는 그냥 값들만 가져와서 연결해서 보여주기만 하기
-> 변수 타입이 맞는지, 계산은 x -> 컴파일은 백엔드에서 할거고 오류나면 responss 보고 결정할거

소스코드 -> store 구조체 안에 넣어놓고 code에서는 구조체 가져와서 쓰기

로직 만들 필요 모습만 맞춰서 만들면 되는거 아님? 값이 실제로 움직일 필요가 있나?

디렉토리 구조
    - sol
        - 각자 솔 파일
    - interface
        - 

사용자가 솔 파일 저장하면 로컬 스토리지에 저장하게

-> 각 솔 파일을 class로 만들고 안에 함수들을 넣어두기 

기본 노드드 모아둔 파일 하나 만들기 -> 기본적인 논리 노드 파일 / 기본 함수 노드 파일

노드
    - id
    - type
    - input
    - output
    - position

엣지
    - fromID
    - toID
    - fromValue
    - toValue

노드 생성 -> 노드, 엣지를 그래프에 추가 -> 그래프는 노드의 position 값 가져와서 출력 & 변경될 때마다 노드의 position 값 수정
-> 컴파일하면 엣지 순서대로 저장 -> backend에 잘 주려면 바이트 코드 형태로 컴파일해야함(컴파일러 만들기)

default 노드들은 컴포넌트도 미리 만들어두기? -> 이게 훨씬 쌀 듯

default 노드 리스트
    //논리연산
    - and
    - or
    - not
    - is
    - nand
    //Math
    - add
    - multi
    - sub
    - minus
    - 나머지
    - ++
    - --
    //조건문
    - if
    - while
    - for
    - switch

